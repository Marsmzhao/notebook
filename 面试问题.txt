1 define和const的不同 ： 编译器对待const常量是在编译期间确定他的数值
                        define是在预处理的过程中 做了简单的替换 在程序运行的过程中是没有这个数值
                        const本质上也是一个变量 有自己的类型 编译器强制保证不会修改
                        一般const在符号表 或者具体内存上 而define是程序段的一个立即数
2:简述http协议：是一层应用层协议 主要分为 http请求包 回复包
    请求包的主要内容：  请求行  方法 uel 版本  
                    请求头    ****：**** \n\r  主要包括：域名 长链接吗 长度 客户端系统之类信息
                    请求体   和请求头之间多了一个空行

    回复包的主要内容： 状态行  版本 状态码 一些状态说明 
                    响应头  长度 服务 日期之类的杂活
                    响应体 html源代码
    常见的请求方法有post和get 两者之间的区别：
                get把参数直接放在url后边丢过去 而post是把参数放在请求体里面
                get只能用这种编码 而请求体里面也可用别的编码方式 因此更为安全
                get数据是有限的 而post数据在请求体里面 因此可以发送很多
    常见的状态码 ： 200 一切ok
                    301  请求改变了服务器上的资源的变化
                    400 客户端发送的内容有错误 希望这个消息引起客户端自我修复
                    404 请求的资源没有找到
                    500 服务器自身有问题
    域名解析过程：首先会从浏览器缓存中查找对应地址
                然后到操作系统中查找
                然后是本地的域名解析服务器 通常有运营商提供
                还没有找到就有本地域名服务器发起 根域名服务器 顶级域名服务器 权限域名服务器
3:两种简单的单例模式：一种依靠局部静态变量 一种依靠new和delete       
4:悲观锁和乐观锁的定义和使用场景：
        乐观锁是每次在获取数据的时候，不加锁 不担心获取的数据被修改，但是在将要修改数据的时候会在获取一次
        比较两次数据是都被修改过，如果修改过就更新数据 。场景就是在读操作频繁的场景
5；linux系统的io模型： 一次io分两个阶段 第一是内核准备数据 第二是把内核准备的数据放到用户缓存区
                （1）阻塞io模型 用户发出一个io请求后 进程阻塞在两个阶段 属于同步阻塞模型
                （2） 非阻塞io 用户发出io请求后 第一个阶段不会阻塞 直接返回 第二个阶段阻塞
                    轮训的方式询问数据是否准备好
                （3）io复用简单来说 一次性阻塞在多个io操作上 其中一个好了返回这个好的 多路复用
                （4）信号驱动模型  注册一个信号处理函数 然后发起io调用的时候会立即返回 当内核准备好数据后
                    回调信号处理函数 在这个函数内读取数据 
                (5) 异步io 发起io调用后 直接返回 第一个阶段和第二个阶段都又内核操作 都完成后 通知用户
5.5 tcp报文格式 ： 源端口 目的端口 
                    序列号 seq 
                    确认号 ack
                    长度 标志为 校验和
6:tcp握手： 1 客户端发送一个 syn请求信号 还有一串序列号seq 状态变为syn_sent
            2 服务器回复一个 ack = x+1 同时也发送一个syn ACK此时服务器状态由listen变为syn_rcvd
            3 客户端收到后 回复一个ACK ack序列号 此时双方状态变为 established

            1客户端发送一个FIN 和一个sqe 状态变为fin_wait1  
            2服务器收到后 回复一个ACK 和一个seq   状态变为closewait 客户端收到后 状态变为finwait2
            3 服务器发送一个fin 和一个sqe 进入last—ack状态 
            4客户端收到以后  状态变为timewait 然后发送一个ack sqe 关闭连接

            tcp握手：为什么是3次握手  主要是为了避免失效的网络包到达服务器 被服务器误认为一次新链接的到来
                假如只有两次链接的话 客户端第一次发的包在网络中被阻塞掉了 客户端没有收到回复 客户端以为这个包没了
                然后发送了第二个包 服务器接受了这个包 回复了这个包 连接到来 
                那么第一个包在某个时刻又到来了 服务器端会认为一个新连接来了 做一次回复建立连接
                但是客户端知道这个包是废弃的 但是他也没有办法告诉服务端 因为连接已经建立了
            tcp挥手： 为啥必须是4次 为了避免一方向终止连接 但是另一方还有没有发送完毕数据
                    所以说发送fin的端 是向对端说明 我不再给你发数据了  
                    因此需要两轮fin才能保证没有数据想要传输了
            什么情况下 会产生rst包 ：1 对端端口服务没打开 
                                2 已经建立连接了 还继续发送syn
                                3 对端服务崩溃了 回复rst包
            tcp为什么稳定 ：1校验和保证
                            2 超时重新传输 每次以0.5ms为基数 一次比一次时间长
                            3 ack回复 回复期望收到的下一个编号
                            4 tcp三次挥手 4次挥手 确保建立一个稳定的连接 断开一个连接
                            5 流量拥塞管理 滑动窗口 
            tcp滑动窗口: 在发送方tcp缓存区存在四个区域 
                    已经发送 已经收到ack的数据 
                    已经发送 还没有ack的数据 
                    还没发送 但是在窗口中准备即将发送的数据 
                    没发送 不在窗口 也不打算发送的数据 
                    其中区域二区域三在滑动 由对端报文的windows字段决定 时刻在变
                    在收到ack后 滑动窗口的左边滑动 右边取决于窗口大小

                    接受端缓冲区也可以按照这个逻辑分类 
                    目前程序的读指针 在这个指针之前 数据被程序读走了
                    还有一个指针指向收到包的最后一位置
                    包不是按顺序到达的 所以中间是不连续的
                    中间还有一个指针 指向连续包的最后一个位置 回复确认也是回复这个未知的下一个位置
                    回复确认后 接受框就会向右滑动
            tcp拥堵控制 ：
                    路由器作为一个中间层 收到的数据速率大于发送数据的速率时候 路由会产生大量缓存
                    进而丢掉了多余的部分数据
                    慢开始：tcp发送方拥有拥塞窗口 初始值为1 还有一个门限数值
                        开始的时候传输速度很慢 但是不发生丢包 这个拥塞窗口就会指数增长 只到门限数值
                    拥塞避免 ： 到达这个门限数值 我们可以认为即将进入拥堵状态 所以放缓了窗口增长的速度 
                        直到碰见丢包 触发了超时重传输 更改窗口和门限
                    慢开始 ：吧门限数值改到阻塞时候的一半 拥塞窗口改一半重复
                    但是 有的时候个别报文段丢失 并没有到达当前上顶峰 也触发了慢开始 降低了速度
                    所以有了：
                    快速重传：发送方一旦收到了三个重复确认 就重传 要求接收方收到一个包以后立刻回复
                        而不是等待超时计时器触发崇川 从而鉴别了个别数据段跌势=丢失
                    快速恢复 ： 在快速重传的阶段上 把门限和窗口都调味当前一半 然后执行拥堵避免

7 osi七层网络模型 ：应用层
                    表示层
                    会话层
                    传输层
                    网络层
                    数据链路层
                    物理层
tcp5层模型：        应用层
                    传输层
                    网络层
                    网络接口层
路由器在那一层
OSI7层协议是哪7层?MAC地址在那一层?
怎么查看当前网卡的连接状态
如何查看当前开启的端口
Linux查找有hello单词行的总行数
堆和栈有什么区别
深度搜索 广度搜索区别 用途
///////////////
hr面问题：
1 为什么选择这个方向
2 为什么选择这里
3 你对工作的预期
4 对这个方向有没有行业上的了解

为什么要考研 
最近有学习什么新技术吗
为什么觉着后台开发适合自己
///////////////

1：进程线程的区别：
2:进程间的通信
3:服务器最大连接数的影响
4:发送包文没有收到ack的原因
5:堆和栈的区别
6:malloc 发生了什么
7:fork共享哪些内容
8:写一个二分查找


介绍一下函数调用
为什么参数从右向左压栈
线程池中线程异常或者死循环了，该如何解决
LINUX创建一个文件夹的过程
有没有用过什么缓存 怎么设计一个LRU，怎么设计一个线程安全的LRU,怎么不用锁设计一个线程安全的LRU
俩个文件，每个文件十亿个URL，找到重复的URL，设计方案！
1. 你如何估计你的项目会使用多大内存
2. 你如何确定自己项目中应该设置的线程池的数量？怎么去量化这个值？
3. 怎么解决tcp粘包问题？说说伪代码怎么写？
一个超大的文件，文件每行是一个数字，找出出现频次最高的5个数字
分块->hash->大顶堆
10亿个手机号找一个？
10亿个手机号的文件转储，如何压缩，同时要能够计数，就是给出一个手机号，判断出现过没，出现过给出出现次数
///////////
如何去除套接字的time_wait的状态？
const是干嘛的？const & 有什么优势？（速度快点），为什么会快？ 如何在下面代码中修改const & string 类型的值？（用const_cast<string &>）
线程和进程是怎么调度的？线程调度和进程调度有什么区别
线程切换和进程切换
C++与C的区别
端口号是用来干什么的
分页和分段是什么
三次握手 第三次没收到怎么办
//////////