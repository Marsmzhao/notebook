基于muduo网络库的项目介绍
1 整体理解 ：
    基于reactor模式的c++网络库，采用同步非阻塞io模型，基于事件回调
    reactor模式（反应器模型）：流程1向时间分发器注册回调函数
                                2事件发生
                                3时间分发器调用回调函数
    muduo的核心是一组循环 在循环中调用epoll 等待事件发生
                        发生后事件循环
2 moduo组件分析：
    (1)eventloop :类内含有 一个poll io复用模块 
                            定时器队列 timequeue
                            附带一个context数据  
                            一组vector 活动通道列表
                            vector仿函数
    eventloop构造函数中 创建了一个唤醒描述符号 通过向文件描述符中写入数据 唤醒poll阻塞
        同时在通道中注册这个描述符号可读回调函数-读一下这个文件描述符避免busyloop
    eventloop主循环中   1:调用poll获得一组活跃通道的列表
                       2:遍历这一组活跃列表 依次调用通道自己的事件分发
                       3:把挂在本个线程的任务执行一遍
                       这里是一个多生产者 单个消费者的模型 因此容器需要加锁 在遍历这个容器的
                       过程中 为了减少持有锁的时间 先把列表复制一遍 然后解除锁
    (2)channel :channel其实就是单个事件（文件描述符号）的时间分发器
                抽象封装了对应 套接字标志 和 回调函数 之间的对应关系        
                含有        读 写 关闭 错误 四个回调函数
                伴随有 关注的事件 发生的事件 索引 文件描述符号四个  标志
                其事件分发 就是根据标志为调用回调函数 
                updatechannel函数 就是将本通道注册到poll中      
    (3)acceptoe 接收器 封装了监听套接字的监听以及accept的链接过程
                构造函数创建一个监听套接字 开启一个 监听套接字 到 accept的通道 返回一个链接套接字
                接收器需要向通道注册可读事件 
                当可读事件发生以后 调用accept函数 获取这个套接字 然后创建一个tcp连接
    (4)tcpConnection 封装了一次连接的全过程 在接收器回调函数中创建
                构造函数 分配了一个通道 并回重写调了管道的四个函数
                    handleread 读数据到缓冲区   处理错误 没错误通知应用层消息到来
                    handlewrite  写一次缓冲区数据 如果全写完了 取消关注write事件 并且通知应用层写完了
                    handleclose 取消通道关注事件 调用一次连接结束回调函数
                    handleerro 打印一次错误而已

                    send函数 尝试发送一次数据 全发完直接调用写完函数 没发送完开启write关注
                所以tcpconnection层面 主要回调用户三个个函数 消息到来 你要写的写完了  连接建立以及断开
    (5) eventloopthread 类：里面带了很多的eventloop 每一个eventloop在一个线程中
                    用一个vector把他们保存起来
    （6）tcpserver服务器 ：自带一个接收器 接收器负责监听套接字 带一个eventloop的vector
                    每当开了一个新连接的时候 new一个tcpconnection 然后找一个eventloop注册进去
                    服务器还是依旧设置三个回调函数 连接到来了 连接结束了 消息来了 你想写的消息写完了 关注三个半
3:面试问题：
   # 面试被问过的问题

* 介绍一下这个项目(几乎是必问的)
* 定时器是怎么实现的？还有什么实现方式？
    定时器对象 和定时器队列组成的
    定时器对象是对何时触发一个什么事件以回调函数的形式做了一次封装 附带一个序号
    定时器队列采用一个set集合 保存了《时间和定时器指针》 因为set不允许重复的 所以采用时间+指针的形式
    定时器队列拥有一个timefd文件描述符号 设定的时间到达 文件描述符可读 这个文件描述符号和io复用是耦合在一起的
    时间到达的时候 会触发可读函数 然后可读函数会获取当前时间 在集合里面找到一个这个时间的分界点
    在这个分界点之前 都会被移除定时器队列 然后丢到一个容器里面 循环执行每个定时器的超时回调函数
    添加一个定时器操作会检查 当前的超时时间 和添加的超时时间 如果新时间更早的花 会重新设定timefd的时间
    一个触发的过程：主循环中的epoll等待的timefd时间到了 可读 触发对应的定时器队列可读函数 返回一个超时列表 依次处理
    定时器插入 定时器删除 如何触发超时  主要数据结构是什么 围绕着三个点回答

    还能怎么实现呢？ std_priority_queue 优先级队列 内部采用小堆数据结构
                主循环首先获取一个超时时间 然后epoll等待这些时间 epoll返回后检查一下到时没有

    时间轮解决空闲连接：

* 实现一个无锁队列(用原子操作)

* eventfd是什么？有什么好处？
    增强了模块之间的耦合 
* 双缓冲区异步日志是什么？为什么要这样做？对这个日志系统有没有进行压力测试？
    双缓冲日志系统意思是拥有两块缓存区域 前端 也就是代码段往缓存区域a写 后端从缓存区域b里面读出来 输出出去
    好处就是不会因为后端正在读这个缓冲区而进入阻塞 每隔一段时间交换两块缓存
    往一个流里面写入遗传代码的流程： 生成一个无名临时栈上log对象 这个对象会立刻把数据格式化好 然后保存在
    在对象析构的时候 会把内部数据送出去 送到A缓冲部分 
    然后额外开一个线程每隔三秒交换一下Ab两块缓存 然后做一次输出

* 什么是优雅关闭连接？(就是read()到0，要透明的传递这个行为而不是直接暴力close())
    优雅关闭就是发送缓存区所有数据发送完毕后 再去4次挥手 调用shutdown而不是clode
    SD_RECEIVE参数说明 我关闭读的一端 不再从里面读取数据 假如这时候缓存区还有数据 或者收到数据 直接rst
    SD_SEND 参数 把缓存区的所有数据发送完毕以后 并且收到所有数据的时候发送一个fin 告知没有数据
    SD_BOTH表明关闭双端

* epoll的边沿触发和水平触发有什么区别？(epoll的源码并不长，从源码的角度回答比较好)
    水平触发和边沿触发是一种epoll的返回机制 以读一个套接字来解释的话就是
    当这个套接字状态从不可读变成可读的时候 触发一次返回 这是边缘触发
    当这个套接字状态处于可读 触发一次返回 这事水平触发

* epoll为什么高效，相比select和poll
    select的话主要用置位的形式 用了三个集合表示关注的事件 每一次调用呢都需要去重制这个集合然后在内核和用户空间反复去传递这些数据
    并且select返回后还要用户认为去遍历一串这个结构 才知道谁发生了 弊端是遍历 拷贝 加有限的监听
    poll的话本质上和select差不多 只是改进了数据结构 不用每次都去生成监听集合 最大数目也取消 但是反复拷贝以及遍历 还是浪费很多时间
    epoll的话是拆分了除了三个函数 epollcreate epollctr epollwait
    epoll底层拥有一串就需链表和一颗红黑树 每次epollctr注册一个事件呢都会去这个红黑树搜索 如果没有搜索到对应事件呢 就会插入进去 
    然后在内核中断注册一个回调函数 触发这个函术后 就会把这个结构插入到就需链表里面 
    epollwait就观察这个就绪链表。
* HTTP报文都有哪些字段？
    请求报文的话 有请求行 包括 请求的方法 请求的地址 请求的版本 请求行  请求题
                回复的话 就是状态行 版本 状态码 状态解释  响应行 响应体
* 假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)
* 有没有实现内存池？
    标准库的二级分配器 还有国外小哥写的内存吃
* 一个请求到来具体的处理过程是怎样的？
    首先是tcp三次握手 三次握手完毕后主分发器监视的linsten套接字变为可读的形式 epoll返回 触发一次监听套接字可读事件
    在这个回调函数中生成了一个tcpconnection类 这个类是对一个连接的抽象 我们还从线程池中以循环的方式选择一个io线程
    去处理这个连接的回调和套接字的监视 
    当对端发送遗传数据给我 会在这个触发这个子io线程的epoll 然后触发事件的分发 回调可读事件
    这个可读事件会对http报文头进行解析 采用状态机的方式分包http的各类参数 保存在一个叫httprequest的类里面
    如果说分包完成后调用解析类 根据解析去构造一个回复http包的状态行 和响应头 然后在具体填充响应体的内容
    构造完毕后会调用send send没有真正的把数据发送出去 而是保存在了缓冲去
    send会尝试发送一次数据 最好的情况是一次直接发送完了 如果没有发送完 就会关注套接字的可读事件
    直到数据发送完成 然后取消关注 这里用的是一个水平触发

* 线程的唤醒还有哪些方式？
    条件变量唤醒 condition——variable 
    eventfd 这个文件描述符不用处理缓冲区 所以损耗的资源少
    管道pipe
* 怎么检查内存泄漏的？
    windows下边有办法就是crt
* 用到了哪些智能指针和RAII机制，几种锁的区别是什么
* 任务队列是怎么实现的，除了加锁还有什么方式？
* 如何解决死锁？
* 怎么进行压测的？
* 为什么要用非阻塞io？
* 为什么要做这个项目？
* Reactor模式是什么？

* 网络库瓶颈在哪里

* 微博服务器为什么会崩掉

###实现一个日志累 
        日志分了三个等级 debug  trace追踪  info正常
        
项目简介：
    整个项目是基于非阻塞io ractor事件驱动模型 
    事件分发器类 封装了文件描述符 和 对应操作的回调函数 
        会根据epoll返回的标志为决定调用那个函数 标志位 ： in out 挂断 错误 紧急
        可读可写关闭错误相当于就是单个文件描述符的事件分发器
    接收器类    创建一个监听套接字 创建一个 时间分发器 注册好回调函数
    tcp连接类   封装一个tcp连接  里面保存了一个事件分发器  和对应事件发生时候 调用的函数 
                可读 可写 结束 错误
                可读函数 读数据进缓冲区 如果有错误 就调用处理错误函数 如果==0 结束掉
                                    如果没错误 就调用用户的读事件
                可写函数  把缓冲区数据写进套接字 如果写完了 就调用写完了函数 取消关注事件
                            如果没写完 就等下一次调用这个函数
                错误    日志输出一条信息 调用关闭
                关闭     回调用户的关闭

                用户函数 连接到来 连接关闭 信息到来 写完了  
    io循环类    调用epoll-wait 返回各个事件分发器类  然后一次调用事件分发起类的事件分发
    服务器类   包含有一个接受器 含有多个io循环类 每一个线程放一个io循环类
                然后把一个新到来的连接 注册到io线程类中

                分发器类  接收器类  连接类  io循环类  服务器封装类 

###终极介绍
    服务器分为两个部分 第一个是c++11结合标准库和boost库写的一个基于epoll的多线程服务器框架
                    第二个是应用层 实现了http的get方法  采用状态机分包 然后构造回复 发送
    服务端架构 采用一个主反应器 加多个子反应器 主反应器负责监听套接字 生成一个tcp连接类
              把accept的连接分发到子反应器中
                子反应器架构是一个循环 循环里面首先等待epoll返回  然后任务分发模块根据具体触发的事件
                在io线程依次处理 也可以推到线程池中处理。
                用户只需要注册 事件到来函数  连接建立函数  连接结束函数   还有一个发送完毕函数
                事件到来函数 拆解为 分包函数  分包完成函数 
                连接建立函数 分配了一个解码器类 类负责分包 并且把分包内容荣保存在map里面 时间轮相关
    应用层架构 拆解一个http请求  构造一个http请求 
                当请求来了以后 调用解码类 状态机解包  
                解释完毕后 调用构造类 去构造一个http回复包 